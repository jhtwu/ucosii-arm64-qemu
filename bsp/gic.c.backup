#include "gic.h"
#include "mmio.h"
#include "uart.h"

#define GICD_BASE           0x08000000u
#define GICR_BASE           0x080A0000u

#define GICD_CTLR           (GICD_BASE + 0x000u)

#define GICR_CTLR           (GICR_BASE + 0x0000u)
#define GICR_WAKER          (GICR_BASE + 0x0014u)

#define GICR_SGI_BASE       (GICR_BASE + 0x10000u)
#define GICR_IGROUPR0       (GICR_SGI_BASE + 0x0080u)
#define GICR_ISENABLER0     (GICR_SGI_BASE + 0x0100u)
#define GICR_ICENABLER0     (GICR_SGI_BASE + 0x0180u)
#define GICR_ISPENDR0        (GICR_SGI_BASE + 0x0200u)
#define GICR_ICFGR0         (GICR_SGI_BASE + 0x0C00u)
#define GICR_IPRIORITYR(n)  (GICR_SGI_BASE + 0x0400u + ((n) * 4u))
#define GICR_IGRPMODR0      (GICR_SGI_BASE + 0x0D00u)

#define TIMER_INTERRUPT_ID  27u

/*
 * Chinese: 讀取 ICC_SRE_EL1 系統暫存器。
 * English: Reads the ICC_SRE_EL1 system register.
 */
static inline uint32_t read_icc_sre_el1(void)
{
    uint64_t value;
    __asm__ volatile("mrs %0, ICC_SRE_EL1" : "=r"(value));
    return (uint32_t)value;
}

/*
 * Chinese: 寫入 ICC_SRE_EL1 系統暫存器。
 * English: Writes to the ICC_SRE_EL1 system register.
 */
static inline void write_icc_sre_el1(uint32_t value)
{
    __asm__ volatile("msr ICC_SRE_EL1, %0" :: "r"((uint64_t)value));
    __asm__ volatile("isb");
}

/*
 * Chinese: 寫入 ICC_CTLR_EL1 系統暫存器。
 * English: Writes to the ICC_CTLR_EL1 system register.
 */
static inline void write_icc_ctlr_el1(uint32_t value)
{
    __asm__ volatile("msr ICC_CTLR_EL1, %0" :: "r"((uint64_t)value));
}

/*
 * Chinese: 寫入 ICC_PMR_EL1 系統暫存器，設定中斷優先級過濾。
 * English: Writes to the ICC_PMR_EL1 system register to set the interrupt priority mask.
 */
static inline void write_icc_pmr_el1(uint32_t value)
{
    __asm__ volatile("msr ICC_PMR_EL1, %0" :: "r"((uint64_t)value));
}

/*
 * Chinese: 寫入 ICC_BPR1_EL1 系統暫存器，設定二進位點。
 * English: Writes to the ICC_BPR1_EL1 system register to set the binary point.
 */
static inline void write_icc_bpr1_el1(uint32_t value)
{
    __asm__ volatile("msr ICC_BPR1_EL1, %0" :: "r"((uint64_t)value));
}

/*
 * Chinese: 寫入 ICC_IGRPEN1_EL1 系統暫存器，啟用 Group 1 中斷。
 * English: Writes to the ICC_IGRPEN1_EL1 system register to enable Group 1 interrupts.
 */
static inline void write_icc_igrpen1_el1(uint32_t value)
{
    __asm__ volatile("msr ICC_IGRPEN1_EL1, %0" :: "r"((uint64_t)value));
    __asm__ volatile("isb");
}

static inline void write_icc_igrpen0_el1(uint32_t value)
{
    __asm__ volatile("msr ICC_IGRPEN0_EL1, %0" :: "r"((uint64_t)value));
    __asm__ volatile("isb");
}

/*
 * Chinese: 初始化通用中斷控制器 (GIC)。
 * English: Initializes the Generic Interrupt Controller (GIC).
 */
void gic_init(void)
{
    uart_puts("[GIC] Starting simplified GIC initialization\n");
    
    /* Skip system register access for now - focus on MMIO setup */
    uart_puts("[GIC] Configuring MMIO registers only\n");
    
    /* Test MMIO access */
    uart_puts("[GIC] Testing MMIO access\n");
    uint32_t gicd_ctrl = mmio_read32(GICD_CTLR);
    uart_puts("[GIC] GICD_CTLR = ");
    uart_write_hex(gicd_ctrl);
    uart_putc('\n');
    
    /* Disable distributor */
    uart_puts("[GIC] Disabling distributor\n");
    mmio_write32(GICD_CTLR, 0u);
    
    /* Test redistributor access */
    uart_puts("[GIC] Testing redistributor access\n");
    uint32_t gicr_ctrl = mmio_read32(GICR_CTLR);
    uart_puts("[GIC] GICR_CTLR = ");
    uart_write_hex(gicr_ctrl);
    uart_putc('\n');
    
    mmio_write32(GICR_CTLR, 0u);

    /* Skip WAKER for now - just do basic interrupt setup */
    uart_puts("[GIC] Configuring basic interrupt settings\n");
    
    uart_puts("[GIC] Configuring interrupt priority and routing\n");
    uint32_t priority = mmio_read32(GICR_IPRIORITYR(TIMER_INTERRUPT_ID / 4u));
    
    /* Skip WAKER for now - just do basic interrupt setup */
    uart_puts("[GIC] Configuring basic interrupt settings\n");
    
    uart_puts("[GIC] Configuring interrupt priority and routing\n");
    uint32_t priority = mmio_read32(GICR_IPRIORITYR(TIMER_INTERRUPT_ID / 4u));
    uint32_t shift = (TIMER_INTERRUPT_ID % 4u) * 8u;
    priority &= ~(0xFFu << shift);
    priority |= (0x80u << shift);
    mmio_write32(GICR_IPRIORITYR(TIMER_INTERRUPT_ID / 4u), priority);

    uint32_t group = mmio_read32(GICR_IGROUPR0);
    group |= (1u << TIMER_INTERRUPT_ID);
    mmio_write32(GICR_IGROUPR0, group);

    uint32_t group_mod = mmio_read32(GICR_IGRPMODR0);
    group_mod |= (1u << TIMER_INTERRUPT_ID);
    mmio_write32(GICR_IGRPMODR0, group_mod);

    mmio_write32(GICR_ICENABLER0, (1u << TIMER_INTERRUPT_ID));
    mmio_write32(GICR_ISENABLER0, (1u << TIMER_INTERRUPT_ID));
    mmio_write32(GICR_ICFGR0, 0u);

    /* Configure ICDICFR for interrupt 27 (virtual timer) like armv8 project */
    uart_puts("[GIC] Configuring ICDICFR for interrupt 27\n");
    /* Note: In GICv3, for PPIs (16-31), configuration is done via redistributor */
    /* Interrupt 27 is in ICDICFR[1] bits [23:22] (27-16)*2 = 22 */
    uint32_t icdicfr1 = mmio_read32(GICR_ICFGR0 + 4);
    icdicfr1 &= ~(0x3u << 22);  /* Clear bits 23:22 */
    icdicfr1 |= (0x1u << 22);   /* Set edge-triggered (01) */
    mmio_write32(GICR_ICFGR0 + 4, icdicfr1);
    
    uart_puts("[GIC] ICDICFR configured for interrupt 27\n");

    uart_puts("[GIC] IGROUPR0=");
    uart_write_hex(mmio_read32(GICR_IGROUPR0));
    uart_puts(" ISENABLER0=");
    uart_write_hex(mmio_read32(GICR_ISENABLER0));
    uart_puts(" ISPENDR0=");
    uart_write_hex(mmio_read32(GICR_ISPENDR0));
    uart_putc('\n');

    uart_puts("[GIC] Enabling distributor (MMIO only)\n");
    mmio_write32(GICD_CTLR, (1u << 0) | (1u << 1) | (1u << 4));

    /* Skip CPU interface system registers for now */
    uart_puts("[GIC] Skipping CPU interface system registers\n");
    
    uart_puts("[GIC] Basic GIC initialization completed\n");
}

/*
 * Chinese: 回應一個中斷請求，並回傳中斷 ID。
 * English: Acknowledges an interrupt request and returns the interrupt ID.
 */
uint32_t gic_acknowledge(void)
{
    uint64_t int_id;
    __asm__ volatile("mrs %0, ICC_IAR1_EL1" : "=r"(int_id));
    return (uint32_t)int_id;
}

/*
 * Chinese: 通知 GIC 中斷處理已完成。
 * English: Notifies the GIC that interrupt processing is complete.
*/
void gic_end_interrupt(uint32_t int_id)
{
    uint64_t value = (uint64_t)int_id;
    __asm__ volatile("msr ICC_EOIR1_EL1, %0" :: "r"(value));
    __asm__ volatile("msr ICC_DIR_EL1, %0" :: "r"(value));
}
